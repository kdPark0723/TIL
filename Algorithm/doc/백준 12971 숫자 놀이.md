# 숫자 놀이 

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 2 초      | 512 MB      | 229  | 111  | 86        | 49.425%   |

## 문제

준서는 얼마 전 나머지연산에 대해 배웠다. 양의 정수 N을 다른 양의 정수 M으로 나눈 나머지는 항상 0이상 M-1이하의 정수가 된다는 사실이 신기한 준서는 혼자만의 숫자놀이를 고안했다.

먼저 준서는 양의 정수 X1, X2, X3 3개를 임의로 고른다. 그 후 3개의 양의 정수 P1, P2, P3을 고르는데, P1 > X1, P2 > X2, P3 > X3을 만족하도록 고른다. 준서가 알고 싶은 것은 아래의 조건을 만족하는 가장 작은 양의 정수 N이다.

N을 P1로 나눈 나머지가 X1, P2로 나눈 나머지가 X2, P3로 나눈 나머지가 X3

준서가 선택한 P1, P2, P3, X1, X2, X3가 주어졌을 때, 가장 작은 정수 N을 찾는 프로그램을 작성하시오.

## 입력

공백으로 구분된 6개의 정수 P1, P2, P3, X1, X2, X3가 순서대로 주어진다. 모든 숫자는 1과 300사이의 정수다.

## 출력

한 줄에 가장 작은 양의 정수 N을 출력한다.

단, 조건을 만족하는 1,000,000,000미만의 양의 정수가 없을 경우 -1을 출력한다.

## 예제 입력 1

```
20 20 20 1 2 3
```

## 예제 출력 1 

```
-1
```

## 예제 입력 2 

```
2 3 5 1 1 1
```

## 예제 출력 2 

```
1
```

## 예제 입력 3 

```
2 4 8 1 2 3
```

## 예제 출력 3 

```
-1
```

## 출처

https://www.acmicpc.net/problem/12971

 

# 풀이

n 이 1부터 p1 * p2 * p3 까지 찾는다.
p1 * p2 * p3 찾는 이유는 이때 부터 나머지가 다시 반복이 되기 때문이다



```kotlin
import java.util.*

fun main() = with(Scanner(System.`in`)) {
    val size = 3

    val p = mutableListOf<Long>()
    for (i in 0 until size) {
        p.add(nextLong())
    }
    val x = mutableListOf<Long>()
    for (i in 0 until size) {
        x.add(nextLong())
    }

    val params = p.mapIndexed { i, value -> value to x[i] }

    val mul = p.reduce { acc, l -> acc * l }
    for (n in 1 .. mul) {
        if (params.all { (p, x) -> n % p == x }) {
            println(n)
            return@with
        }
    }

    println(-1)
}
```