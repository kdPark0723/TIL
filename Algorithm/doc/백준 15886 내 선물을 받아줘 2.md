# 내 선물을 받아줘 2

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 2 초      | 256 MB      | 152  | 102  | 96        | 67.133%   |

## 문제

욱제는 구사과의 열렬한 팬이다. 오늘 욱제는 구사과에게 선물(![img](https://upload.acmicpc.net/c725ab53-dfed-4cdd-a508-aaa6e917a04d/-/preview/))을 전달해주려고 한다. 지난 며칠간의 관찰 끝에 욱제는 구사과의 이동 패턴을 모두 파악했다.

구사과가 있는 곳은 1×N 크기의 직사각형 지도로 나타낼 수 있으며, 1×1크기의 정사각형으로 나누어져 있다. 구사과의 위치는 (1, x)로 나타낼 수 있으며, (1, x)는 왼쪽에서부터 x번째 칸을 의미한다.

지도의 각 칸에는 E, W중의 한 문자가 쓰여져 있는데, 구사과는 이 문자를 이용해서 이동한다. 구사과의 위치가 (1, x)인 경우에 E가 쓰여져 있는 칸에 서 있었다면, (1, x+1)로, W의 경우에는 (1, x-1)로 순간이동한다. 구사과는 지치지 않기 때문에, 계속해서 이동한다.

욱제는 구사과의 위치를 모르기 때문에, 구사과가 이동을 시작하는 위치와 관계없이 선물을 주는 방법을 알아내려고 한다. 최소 몇 개의 칸 위에 선물을 놓으면, 구사과가 항상 선물을 가져가는지 구하는 프로그램을 작성하시오. 선물이 놓여진 칸에 구사과가 이동하면, 구사과는 항상 선물을 가져간다.

## 입력

첫째 줄에 골목길의 길이 N이 주어진다. (2 ≤ N ≤ 1,000)

둘째 줄에 길이 N짜리 구사과가 있는 곳의 지도가 주어진다.

지도에 쓰여 있는대로 이동했을 때, 지도를 벗어나는 경우는 없다.

## 출력

첫째 줄에 최소 몇 개의 칸에 선물을 놓아야 하는지 출력한다.



## 예제 입력 1 복사

```
6
EEWWEW
```

## 예제 출력 1 복사

```
2
```

## 예제 입력 2 복사

```
5
EEEEW
```

## 예제 출력 2 복사

```
1
```



## 출처

<https://www.acmicpc.net/problem/15886>



## 풀이

 E이면 오른쪽으로 이동하고 W이면 왼쪽으로 이동한다. 따라서 E가 반복되는 경우는 그 위치들이 모두 갈 수 있는 위치들은 처음 W가 오른쪽에서 만나는 위치와 가장 오른쪽에 위치한 E의 위치이고 W가 반복 되는 경우 그 위치들이 모두 갈 수 있는 위치들은 처음 읜쪽에서 나오는 E와 가장 읜쪽에 위치한 W이다. 따라서 어떤 문자열이 주어 졌을때 E ... EW ... W인 문자열이 나오면 모든 위치는 E와 W가 만나는 위치에 존재하는 E와 W에 갈 수 있다. 문제에서 가장 최소 가지수를 구하라고 하였으므로 문자열을 순회하며 "EW"가 나오는 개수를 구하면 된다.



### 입력 코드

```c++
int N;
cin >> N;

vector<char> str(N, '\0');
for (int i = 0; i < N; ++i)
    cin >> str[i];
```

### 출력 코드

```c++
cout << count;
```



### 개수 구하기

```c++
int count = 0;
char pre = str[0];
for (int i = 1; i < N; ++i) {
    if (pre == 'E' && str[i] == 'W')
        count++;
    pre = str[i];
}
```



### 전체 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int N;
    cin >> N;

    vector<char> str(N, '\0');
    for (int i = 0; i < N; ++i)
        cin >> str[i];

    int count = 0;
    char pre = str[0];
    for (int i = 1; i < N; ++i) {
        if (pre == 'E' && str[i] == 'W')
            count++;
        pre = str[i];
    }

    cout << count;
    
    return 0;
}
```



### 공간 복잡도

- O(N)

### 시간 복잡도

- O(N)



### 입력과 개수 구하는 코드를 합쳤을 때

```c++
#include <iostream>

using namespace std;

int main() {
    int N;
    cin >> N;

    int count = 0;
    char pre, ch;
    cin >> pre;
    for (int i = 1; i < N; ++i) {
        cin >> ch;
        if (pre == 'E' && ch == 'W')
            count++;
        pre = ch;
    }

    cout << count;
    
    return 0;
}
```



### 공간 복잡도

- O(1)

### 시간 복잡도

- O(N)



## 오답 노트

| 채점 번호 | 아이디                                                | 문제 번호                                      | 결과             | 메모리 | 시간 | 언어                                                         | 코드 길이 | 제출한 시간                                                  |
| :-------- | :---------------------------------------------------- | :--------------------------------------------- | :--------------- | :----- | :--- | :----------------------------------------------------------- | :-------- | :----------------------------------------------------------- |
| 13152088  | [kdpark0723](https://www.acmicpc.net/user/kdpark0723) | [15886](https://www.acmicpc.net/problem/15886) | **맞았습니다!!** | 1988   | 0    | [C++11](https://www.acmicpc.net/source/13152088) / [수정](https://www.acmicpc.net/submit/15886/13152088) | 393       | [8분 전](https://www.acmicpc.net/status?from_mine=1&problem_id=15886&user_id=kdpark0723#) |

- 처음 문제를 보고 DP를 사용하여 문제를 풀려고 했다. 그리고 예제들을 보고 그냥 문자열 순회를 하면 되겠다고 생각해서 노선을 번경했다.
- 문제를 풀때 먼저 문제를 손으로 풀어보고 코드로 작성하는게 효율적인 방법인거 같다

