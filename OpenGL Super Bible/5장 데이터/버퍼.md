# OpenGL Super Bible

## 버퍼

- 타입이 정해져 있지 않는 연속 공간

### 버퍼를 사용하여 메모리 할당

#### 이름 예약

```c
void glGenBuffers(GLsizei n, GLuint * buffers);
```

- 버퍼에 대한 이름을 생성하는 함수

##### 에러

- `GL_INVALID_VALUE` n이 음수 일때 발생

#### 바인딩

```c
void glBindBuffer(GLenum target, GLuint buffer);
```

- 버퍼를 바인딩 포인트 (target)을 이용하여 콘텍스트에 바인딩한다.

##### 에러

- `GL_INVALID_ENUM` target이 잘못되었을때 발생
- `GL_INVALID_VALUE` buffer가 생성되지 않았을때 발생 (glGenBuffers이 그전에 호출되지 않았을 때 발생)

#### 메모리 할당

```c
void glBufferData(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage);
 
void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
```

- 버퍼에 사용할 메모리를 할당시키는 함수

##### 에러

- `GL_INVALID_ENUM` is generated by `glBufferData` if *target* is not one of the accepted buffer targets.

- `GL_INVALID_ENUM` is generated if *usage* is not `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`,`GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`.

- `GL_INVALID_VALUE` is generated if *size* is negative.

- `GL_INVALID_OPERATION` is generated by `glBufferData` if the reserved buffer object name 0 is bound to *target*.

- `GL_INVALID_OPERATION` is generated by `glNamedBufferData` if buffer is not the name of an existing buffer object.

- `GL_INVALID_OPERATION` is generated if the `GL_BUFFER_IMMUTABLE_STORAGE` flag of the buffer object is `GL_TRUE`.

- `GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store with the specified *size*.

#### 버퍼를 생성하고 바인딩하고 초기화

```c
// 버퍼의 이름의 타입은 GLint
GLint buffer;

// 버퍼에 대한 이름 생성
glGenBuffer(1, &buffer);

// 버퍼를 콘텍스트에 바인딩
glBindBuffer(GL_ARRAY_BUFFER, buffer);

// 버퍼에 사용하고자 하는 스토리지의 크기를 정함
glBufferData(GL_ARRAY_BUFFER, 1024*1024, NULL, GL_STATIC_DRAW);
```

#### 이미 사용하던 데이터의 전달

```c
void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data);
 
void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
```

##### 에러

- `GL_INVALID_ENUM` is generated by `glBufferSubData` if *target* is not one of the accepted buffer targets.

- `GL_INVALID_OPERATION` is generated by `glBufferSubData` if zero is bound to *target*.

- `GL_INVALID_OPERATION` is generated by `glNamedBufferSubData` if *buffer* is not the name of an existing buffer object.

- `GL_INVALID_VALUE` is generated if *offset* or *size* is negative, or if offset+sizeoffset+size is greater than the value of `GL_BUFFER_SIZE` for the specified buffer object.

- `GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is mapped with [glMapBufferRange](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml) or [glMapBuffer](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml), unless it was mapped with the`GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` *access* flags.

- `GL_INVALID_OPERATION` is generated if the value of the `GL_BUFFER_IMMUTABLE_STORAGE` flag of the buffer object is `GL_TRUE` and the value of `GL_BUFFER_STORAGE_FLAGS` for the buffer object does not have the `GL_DYNAMIC_STORAGE_BIT` bit set.

  

### OpenGL Warp

#### 코드

```c++
namespace gl {

class Buffer : public BaseObject<Buffer> {
 public:
  enum class Target {
    Array = GL_ARRAY_BUFFER,
    AtomicCounter = GL_ATOMIC_COUNTER_BUFFER,
    CopyRead = GL_COPY_READ_BUFFER,
    CopyWRITE = GL_COPY_WRITE_BUFFER,
    DispatchIndirect = GL_DISPATCH_INDIRECT_BUFFER,
    DrawIndirect = GL_DRAW_INDIRECT_BUFFER,
    ElementArray = GL_ELEMENT_ARRAY_BUFFER,
    PixelPack = GL_PIXEL_PACK_BUFFER,
    PixelUnpack = GL_PIXEL_UNPACK_BUFFER,
    Query = GL_QUERY_BUFFER,
    ShaderStorage = GL_SHADER_STORAGE_BUFFER,
    Texture = GL_TEXTURE_BUFFER,
    TransformFeedback = GL_TRANSFORM_FEEDBACK_BUFFER,
    Uniform = GL_UNIFORM_BUFFER,
  };

  enum class Usage {
    StreamDraw = GL_STREAM_DRAW,
    StreamRead = GL_STREAM_READ,
    StreamCopy = GL_STREAM_COPY,

    StaticDraw = GL_STATIC_DRAW,
    StaticRead = GL_STATIC_READ,
    StaticCopy = GL_STATIC_COPY,

    DynamicDraw = GL_DYNAMIC_DRAW,
    DynamicRead = GL_DYNAMIC_READ,
    DynamicCopy = GL_DYNAMIC_COPY,
  };

  inline Buffer(size_t size = 0);
  inline virtual ~Buffer();

  inline void setSize(size_t size);

  inline void bind(Target target);
  inline void data(const GLvoid *data, Usage usage);
  inline void subData(int offset, const GLvoid *data);

 protected:
  size_t size;
  bool isBind;
};

}
```

```c++
gl::Buffer::Buffer(size_t size)
  : size{size}, isBind{false} {
  glGenBuffers(1, &name);
}
gl::Buffer::~Buffer() {
  glDeleteBuffers(1, &name);
}

void gl::Buffer::setSize(size_t size) {
  this->size = size;
}

void gl::Buffer::bind(Buffer::Target target) {
  this->target = target;
  glBindBuffer(gl::getGLenum(target), name);
}

void gl::Buffer::data(const GLvoid *data, Buffer::Usage usage) {
  if (!isBind)
    gl::errorHandle(gl::Error::GL, "It is't bind.");
  glNamedBufferData(name, gl::getGLsizeiptr(size), data, gl::getGLenum(usage));
}

void gl::Buffer::subData(int offset, const GLvoid *data) {
  glNamedBufferSubData(name, offset, gl::getGLsizeiptr(size), data);
}
```

#### 개선해야 할점

- 불필요하게 낭비되는 메모리(size, isBind)가 있다. 

- gl::Buffer::data, gl::Buffer::subData 함수가 직관적이지 않다.
- 에러 처리가 완전 하지 않다.

#### 1차 수정

```c++
namespace gl {

class Buffer : public BaseObject<Buffer> {
 public:
  enum class Target {
    Array = GL_ARRAY_BUFFER,
    AtomicCounter = GL_ATOMIC_COUNTER_BUFFER,
    CopyRead = GL_COPY_READ_BUFFER,
    CopyWRITE = GL_COPY_WRITE_BUFFER,
    DispatchIndirect = GL_DISPATCH_INDIRECT_BUFFER,
    DrawIndirect = GL_DRAW_INDIRECT_BUFFER,
    ElementArray = GL_ELEMENT_ARRAY_BUFFER,
    PixelPack = GL_PIXEL_PACK_BUFFER,
    PixelUnpack = GL_PIXEL_UNPACK_BUFFER,
    Query = GL_QUERY_BUFFER,
    ShaderStorage = GL_SHADER_STORAGE_BUFFER,
    Texture = GL_TEXTURE_BUFFER,
    TransformFeedback = GL_TRANSFORM_FEEDBACK_BUFFER,
    Uniform = GL_UNIFORM_BUFFER,
  };

  enum class Usage {
    StreamDraw = GL_STREAM_DRAW,
    StreamRead = GL_STREAM_READ,
    StreamCopy = GL_STREAM_COPY,

    StaticDraw = GL_STATIC_DRAW,
    StaticRead = GL_STATIC_READ,
    StaticCopy = GL_STATIC_COPY,

    DynamicDraw = GL_DYNAMIC_DRAW,
    DynamicRead = GL_DYNAMIC_READ,
    DynamicCopy = GL_DYNAMIC_COPY,
  };

  struct Data {
    template <typename T>
    Data(T &data) : data{&data}, size{sizeof(data)} {}

    void *data;
    size_t size;
  }

  inline Buffer();
  inline virtual ~Buffer();

  inline void bind(Target target);
  
  inline void alloc(size_t size, Usage usage);
  inline void alloc(const Data &data, Usage usage);
    
  inline void update(int offset, const Data &data);
};

}
```

- size, isBind 변수를 제거했다. 

- gl::Buffer::data, gl::Buffer::subData 함수의 이름 직관적이게 바꿨다.
- 데이터 전달을 위한 Data 구조체를 만들어서 전달하여 추상화 레벨을 올렸다.