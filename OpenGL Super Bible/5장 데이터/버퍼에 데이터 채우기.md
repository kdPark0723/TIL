# OpenGL Super Bible

## 버퍼에 데이터 채우기

### 특정 오프셋 이후부터 채우기

```c
void glClearBufferSubData(GLenum target,
 	GLenum internalformat,
 	GLintptr offset,
 	GLsizeiptr size,
 	GLenum format,
 	GLenum type,
 	const void * data);
 
void glClearNamedBufferSubData(GLuint buffer,
 	GLenum internalformat,
 	GLintptr offset,
 	GLsizeiptr size,
 	GLenum format,
 	GLenum type,
 	const void *data);
```

#### Errors

- `GL_INVALID_ENUM` is generated by `glClearBufferSubData` if *target* is not one of the generic buffer binding targets.
- `GL_INVALID_VALUE` is generated by `glClearBufferSubData` if no buffer is bound to *target*.
- `GL_INVALID_OPERATION` is generated by `glClearNamedBufferSubData` if *buffer* is not the name of an existing buffer object.
- `GL_INVALID_ENUM` is generated if *internalformat* is not one of the valid sized internal formats listed in the table above.
- `GL_INVALID_VALUE` is generated if *offset* or *range* are not multiples of the number of basic machine units per-element for the internal format specified by *internalformat*. This value may be computed by multiplying the number of components for *internalformat* from the table by the size of the base type from the table.
- `GL_INVALID_VALUE` is generated if *offset* or *size* is negative, or if offset+sizeoffset+size is greater than the value of `GL_BUFFER_SIZE` for the buffer object.
- `GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is mapped with [glMapBufferRange](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml) or [glMapBuffer](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml), unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` *access* flags.
- `GL_INVALID_VALUE` is generated if *format* is not a valid format, or *type* is not a valid type.

### OpenGL Warp

```c++
namespace gl {

class Buffer : public BaseObject<Buffer> {
 public:
  enum class Target {
    Array = GL_ARRAY_BUFFER,
    AtomicCounter = GL_ATOMIC_COUNTER_BUFFER,
    CopyRead = GL_COPY_READ_BUFFER,
    CopyWRITE = GL_COPY_WRITE_BUFFER,
    DispatchIndirect = GL_DISPATCH_INDIRECT_BUFFER,
    DrawIndirect = GL_DRAW_INDIRECT_BUFFER,
    ElementArray = GL_ELEMENT_ARRAY_BUFFER,
    PixelPack = GL_PIXEL_PACK_BUFFER,
    PixelUnpack = GL_PIXEL_UNPACK_BUFFER,
    Query = GL_QUERY_BUFFER,
    ShaderStorage = GL_SHADER_STORAGE_BUFFER,
    Texture = GL_TEXTURE_BUFFER,
    TransformFeedback = GL_TRANSFORM_FEEDBACK_BUFFER,
    Uniform = GL_UNIFORM_BUFFER,
  };

  enum class Usage {
    StreamDraw = GL_STREAM_DRAW,
    StreamRead = GL_STREAM_READ,
    StreamCopy = GL_STREAM_COPY,

    StaticDraw = GL_STATIC_DRAW,
    StaticRead = GL_STATIC_READ,
    StaticCopy = GL_STATIC_COPY,

    DynamicDraw = GL_DYNAMIC_DRAW,
    DynamicRead = GL_DYNAMIC_READ,
    DynamicCopy = GL_DYNAMIC_COPY,
  };

  enum class Format {
    RED = GL_RED,
    RG = GL_RG,
    RGB = GL_RGB,
    RGBA = GL_RGBA,
  };

  template <int N>
  constexpr static Format getFormat();

  enum class Type {
    Byte = GL_BYTE,
    Unsigned_Byte = GL_UNSIGNED_BYTE,
    Short = GL_SHORT,
    Unsigned_Short = GL_UNSIGNED_SHORT,
    Int = GL_INT,
    Unsigned_Int = GL_UNSIGNED_INT,
    Float = GL_FLOAT,
    Double = GL_DOUBLE,
  };

  template <typename T>
  constexpr static Type getType();

  enum class InternalFormat {
    R8 = GL_R8,
    R16 = GL_R16,
    R16F = GL_R16F,
    R32F = GL_R32F,
    R8I = GL_R8I,
    R16I = GL_R16I,
    R32I = GL_R32I,
    R8UI = GL_R8UI,
    R16UI = GL_R16UI,
    R32UI = GL_R32UI,
//    R32U = GL_R32U,

    RG8 = GL_RG8,
    RG16 = GL_RG16,
    RG16F = GL_RG16F,
    RG32F = GL_RG32F,
    RG8I = GL_RG8I,
    RG16I = GL_RG16I,
    RG32I = GL_RG32I,
    RG8UI = GL_RG8UI,
    RG16UI = GL_RG16UI,
    RG32UI = GL_RG32UI,

    RGB8 = GL_RGB8,
    RGB16I = GL_RGB16I,
    RGB32F = GL_RGB32F,
    RGB32I = GL_RGB32I,
    RGB8I = GL_RGB8I,
    RGB32UI = GL_RGB32UI,

    RGBA8 = GL_RGBA8,
    RGBA16 = GL_RGBA16,
    RGB16UI = GL_RGB16UI,
    RGBA16F = GL_RGBA16F,
    RGBA32F = GL_RGBA32F,
    RGBA8I = GL_RGBA8I,
    RGBA16I = GL_RGBA16I,
    RGBA32I = GL_RGBA32I,
    RGBA8UI = GL_RGBA8UI,
    RGBA16UI = GL_RGBA16UI,
    RGBA32UI = GL_RGBA32UI,
  };

  template <Type type, Format format>
  constexpr static InternalFormat getInternalFormat();

  struct Data {
    template <typename T>
    Data(const T &data) : data{&data}, size{sizeof(data)} {}

    void *data;
    size_t size;
  };

  inline Buffer();
  inline virtual ~Buffer();

  inline void bind(Target target);
  
  inline void alloc(size_t size, Usage usage);

  template <Target target>
  inline static void alloc(size_t size, Usage usage);

  inline void alloc(const Data &data, Usage usage);

  template <Target target>
  inline static void alloc(const Data &data, Usage usage);

  inline void update(const Data &data, int offset);

  template <Target target>
  inline static void update(const Data &data, int offset);

  inline void* map(Usage usage);

  template <Target target>
  inline static void* map(Usage usage);

  inline void unmap();

  template <Target target>
  inline void unmap();

  template <typename T, int N>
  inline void clear(const T (&data)[N]);

  template <Target target, typename T, int N>
  inline static void clear(const T (&data)[N]);

  template <typename T, int N>
  inline void clear(const T (&data)[N], int offset);

  template <Target target, typename T, int N>
  inline static void clear(const T (&data)[N], int offset);
};

}
```

- glClearBufferSubData, glClearBufferData 함수의 인자가 너무 많아서 인자를 줄이는 것이 목표였다. 
- 템플릿을 사용하여 인자로 들어온 값에서 적절한 internalformat, size, format, type, data를 추정하게 했다.

#### 예제

```c++
Buffer buffer();
int a[3] = {0};
buffer().clear(a);
```